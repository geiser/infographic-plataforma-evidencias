# concat columns from a df
concat.columns <- function(df, columns, sep='') {
  to_return <- df[[columns[1]]]
  if (length(columns) > 1) {
    to_return <- paste0(
      to_return
      , do.call(
        paste0
        , lapply(columns[2:length(columns)], FUN = function(x) {
          v <- df[[x]]; v[is.na(v)] <-''; return(paste0(sep,v))
        })))
  }
  return(to_return)
}

# parameters to get data from CSVs
default.csv.params <- function() {
  
  to_return <- list(
    assessmentValue = list(src='data/assessment.csv', id='Avaliação da Evidência', name='Avaliação da Evidência')
    
    , period = list(src='data/evidencias.csv', id='Cód. Ciclo', name='Ciclo')
    , technologyType = list(src='data/evidencias.csv', id='Tipo de Tecnologia', name="Tipo de Tecnologia"
      , extra.fields=list(period='Cód. Ciclo'))
    , technology = list(src='data/evidencias.csv', id='Cód. Tecnologia', name="Cód. Tecnologia"
      , extra.fields=list(technologyType='Tipo de Tecnologia', period='Cód. Ciclo'))
    , evidence = list(src='data/evidencias.csv', id='Cód. Evidência', name='Evidência'
      , extra.fields=list(technology='Cód. Tecnologia', technologyType='Tipo de Tecnologia', period='Cód. Ciclo'))

    , dimension = list(src='data/criterios.csv', id='Dimensão', name='Dimensão')
    , criteria = list(src='data/criterios.csv', id='Cód. Critério', name=c('Cód. Item Edital','Critério')
      , extra.fields=list(dimension='Dimensão'))
  )
  
  for (key in names(to_return)) {
    if (!is.null(to_return[[key]][['src']])) {
      df <- read_csv(to_return[[key]][['src']])
      df[['id']] <- df[[to_return[[key]]$id]]
      df[['name']] <- concat.columns(df, to_return[[key]]$name, '.')
      for(nfield in names(to_return[[key]]$extra.fields)) {
        df[[nfield]] <- df[[to_return[[key]]$extra.fields[[nfield]]]]
      }
      to_return[[key]][['df']] <- unique(df)
      
      u_df <- unique(df[,c('id','name')])
      u_list <- as.list(u_df$name)
      names(u_list) <- u_df$id
      to_return[[key]][['unique']] <- u_list
    }
  }
  
  return(to_return)
}

# returns a pair-list <name,id> for a key
get_choices <- function(key, filters = list(), csv.params = default.csv.params()) {
  df <-  csv.params[[key]]$df
  
  idx <- !is.na(df$id)
  for (nfilter in names(filters)) {
    if (all(nfilter %in% colnames(df)) && length(filters[[nfilter]]) > 0) {
      idx <- idx & (df[[nfilter]] %in% filters[[nfilter]])
    }
  }
  
  df <- df[idx,]
  df <- unique(df[,c('id','name')])
  to_return <- as.list(df$id)
  names(to_return) <- df$name
  return(to_return)
}

# get data
get_data <- function(dtype, filters = list(), options = list(), csv.params = default.csv.params()) {
  library(pivottabler)
  if (length(options$assessmentValue) == 0) return(NULL)
  
  if (dtype == 'assessment-result') {
    
    df <- read_csv('data/assessment.csv')
    fields <- list(
      period = 'Cód. Ciclo'
      , dimension = 'Dimensão', criteria = 'Cód. Critério'
      , technologyType='Tipo de Tecnologia', technology='Cód. Tecnologia'
      , evidence = 'Cód. Evidência'
      , appraiser='Avaliação consolidadora?'
      , assessmentValue = 'Avaliação da Evidência'
    )
    
    ## Apply filters
    idx <- rep(T, nrow(df))
    if (options$appraiser != 'all') {
      idx <- idx & (df[[fields$appraiser]] == ifelse(options$appraiser=='main','S','N'))
    }
    
    for (nfilter in names(filters)) {
      if (all(nfilter %in% colnames(fields)) && length(filters[[nfilter]]) > 0) {
        idx <- idx & (df[[nfilter]] %in% filters[[nfilter]])
      }
    }
    df <- df[idx,]
    
    ##
    rdata <- data.frame()
    if (nrow(df) == 0) return(rdata)
    
    categories = c('period')
    if (length(filters$technology) > 0) {
      categories <- c(categories, 'technology')
    } else if (length(filters$technologyType) > 0) {
      categories <- c(categories, 'technologyType')
    }
    if (length(filters$criteria) > 0) {
      categories <- c(categories, 'criteria')
    } else if (length(filters$dimension) > 0) {
      categories <- c(categories, 'dimension')
    }
    df[['Category']] <- concat.columns(
      df,
      as.vector(sapply(categories, FUN = function(x) fields[[x]]))
      , sep = ':')
    
    ## iterate by groups
    for (categ in unique(df[['Category']])) {
      vdf <- df[(df[['Category']] == categ),]
      if (nrow(vdf) == 0) next;
      
      vdata <- PivotTable$new()
      vdata$addData(vdf)
      
      vdata$addColumnDataGroups(fields$assessmentValue)
      vdata$addRowDataGroups(fields$criteria)
      vdata$defineCalculation(calculationName = "Total", summariseExpression="n()")
      vdata$evaluatePivot()
      
      pdata <- vdata$asDataFrame()
      if (nrow(pdata) < 2) next;
      pdata[['id']] <- rownames(pdata)
      pdata[is.na(pdata)] <- 0
      for (value in options$assessmentValue) {
        if (!(value %in% colnames(pdata))) pdata[[value]] <- rep(0,nrow(pdata))
        pdata[[paste0('Pct.',value)]] <- round((100*pdata[[value]])/pdata$Total,2)
      }
      pdata <- pdata[(1:nrow(pdata)-1),]
      
    }
    
    for (period in filters$period) {
      
      if (nrow(pdata) > 1) {
        
        
        pdata <- merge(
          pdata
          , csv.params$criteria$df[,c('id','name',csv.params$criteria$fields$dimension)]
          , by.x='id', by.y='id')
        pdata[['period']] <- rep(period, nrow(pdata))
        if (nrow(rdata) == 0) { rdata <- pdata } else { rdata <- rbind(rdata, pdata) }
      }
    }

    rdata <- data.frame()
    
    if (nrow(df) == 0) return(rdata)
    
    
    if (nrow(rdata) > 1) {
      rdata <- rdata[,c('period',csv.params$criteria$fields$dimension
                        ,'id','name',options$assessmentValue,paste0('Pct.',options$assessmentValue))]
      
      orderBy <- options$assessmentValue
      if (!is.null(options$orderBy) && length(options$orderBy)>0) {
        orderBy <- options$orderBy
      }
      if (options$measurement == 'pct') orderBy <- paste0('Pct.',orderBy)
      
      rdata <- data.table::setorderv(rdata, orderBy, rep(-1,length(orderBy)))
      if (!is.null(options$limit) && !is.na(options$limit) && options$limit > 0) {
        rdata <- head(rdata, options$limit)
      }
    }
    return(rdata)
  }
}

# get data as data frame
get_data.as.df <- function(dtype, filters = list(), options = list(), csv.params = default.csv.params()) {
  
    
  # filters = list(technologyType='Física', dimension=c('Acessibilidade'))
  
}

# get plotly object for a query data
get_plotly <- function(dtype, ctype, filters = list(), options = list(), csv.params = default.csv.params()) {
  library(plotly)
  
  df <- get_data.as.df(dtype, filters = filters, options = options, csv.params = csv.params)
  
  # RadarChart, Dot Chart
  p <- plot_ly(type=ctype, mode='lines+markers')
  if (dtype == 'assessment-result') {
    if (ctype == 'scatterpolar') {
      p <- plot_ly(type = ctype, fill = 'toself')
      for (period in filters$period) {
        for (value in options$assessmentValue) {
          name <- paste0('Qty of evidences assessed as ', value)
          if (options$measurement == 'pct') {
            name <- paste0('Pct of evidences assessed as ', value)
            value <- paste0('Pct.',value)
          }
          
          p_idx <- (df$period == period)
          r <- df[[value]][p_idx]
          theta <- df$name[p_idx]
          p <- add_trace(
            p, r = r, theta = theta
            , name = paste0(csv.params$period$unique[[period]],':',name)
          )
        }
      }
    } else if (ctype == 'stackedbar') {
      
      p <- plot_ly(type='bar')
      axis_x <- unique(df[[csv.params$criteria$fields$dimension]])
      for (value in options$assessmentValue) {
        if (options$measurement == 'pct') value <- paste0('Pct.',value)
        axis_y <- as.vector(sapply(axis_x, FUN = function(x) {
          mean(df[[value]][df[[csv.params$criteria$fields$dimension]] ==x])
        }))
        p <- add_trace(p, x=axis_x, y=axis_y, name=value)
      }
      p <- layout(p, barmode = 'stack')
    }
    
    p <- layout(p, legend=list(orientation = 'h'))
  }
  return(p)
}
